/*
**==============================================================================
**
** ODatatLite ver. 0.0.3
**
** Copyright (c) Microsoft Corporation
**
** All rights reserved. 
**
** MIT License
**
** Permission is hereby granted, free of charge, to any person obtaining a copy ** of this software and associated documentation files (the ""Software""), to 
** deal in the Software without restriction, including without limitation the 
** rights to use, copy, modify, merge, publish, distribute, sublicense, and/or 
** sell copies of the Software, and to permit persons to whom the Software is 
** furnished to do so, subject to the following conditions: The above copyright ** notice and this permission notice shall be included in all copies or 
** substantial portions of the Software.
**
** THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
** AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
** OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN 
** THE SOFTWARE.
**
**==============================================================================
*/
#include <ctype.h>
#include "base64.h"

/* This table generated by base64 program from this distro */
static unsigned char _table[] =
{
#if defined(USE_FULL_TABLE)
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
#endif /* defined(USE_FULL_TABLE) */
    0x3E, /* '+' */
    0xFF,
    0xFF,
    0xFF,
    0x3F, /* '/' */
    0x34, /* '0' */
    0x35, /* '1' */
    0x36, /* '2' */
    0x37, /* '3' */
    0x38, /* '4' */
    0x39, /* '5' */
    0x3A, /* '6' */
    0x3B, /* '7' */
    0x3C, /* '8' */
    0x3D, /* '9' */
    0xFF,
    0xFF,
    0xFF,
    0x40, /* '=' */
    0xFF,
    0xFF,
    0xFF,
    0x00, /* 'A' */
    0x01, /* 'B' */
    0x02, /* 'C' */
    0x03, /* 'D' */
    0x04, /* 'E' */
    0x05, /* 'F' */
    0x06, /* 'G' */
    0x07, /* 'H' */
    0x08, /* 'I' */
    0x09, /* 'J' */
    0x0A, /* 'K' */
    0x0B, /* 'L' */
    0x0C, /* 'M' */
    0x0D, /* 'N' */
    0x0E, /* 'O' */
    0x0F, /* 'P' */
    0x10, /* 'Q' */
    0x11, /* 'R' */
    0x12, /* 'S' */
    0x13, /* 'T' */
    0x14, /* 'U' */
    0x15, /* 'V' */
    0x16, /* 'W' */
    0x17, /* 'X' */
    0x18, /* 'Y' */
    0x19, /* 'Z' */
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0x1A, /* 'a' */
    0x1B, /* 'b' */
    0x1C, /* 'c' */
    0x1D, /* 'd' */
    0x1E, /* 'e' */
    0x1F, /* 'f' */
    0x20, /* 'g' */
    0x21, /* 'h' */
    0x22, /* 'i' */
    0x23, /* 'j' */
    0x24, /* 'k' */
    0x25, /* 'l' */
    0x26, /* 'm' */
    0x27, /* 'n' */
    0x28, /* 'o' */
    0x29, /* 'p' */
    0x2A, /* 'q' */
    0x2B, /* 'r' */
    0x2C, /* 's' */
    0x2D, /* 't' */
    0x2E, /* 'u' */
    0x2F, /* 'v' */
    0x30, /* 'w' */
    0x31, /* 'x' */
    0x32, /* 'y' */
    0x33, /* 'z' */
#if defined(USE_FULL_TABLE)
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
#endif /* defined(USE_FULL_TABLE) */
};

INLINE unsigned char Dec(unsigned char c)
{
#if defined(USE_FULL_TABLE)
    return _table[c];
#else
    if (c < '+' || c > 'z')
        return 0xFF;

    return _table[c - '+'];
#endif
}

int Base64Dec(
    Base64DecState* state,
    const char* data_,
    size_t size_,
    void* dataOut,
    size_t sizeOut)
{
    switch (state->state)
    {
        case 0:
        {
            state->data = (unsigned char*)data_;
            state->size = size_;
            state->end = state->data + state->size;
            state->n = 0;
            goto state0;
        }
        case 1:
        {
            goto state1;
        }
        default:
        {
            goto state2;
        }
    }

state0:

    /* The buffer size must be a multiple of four */
    if (state->size % 4)
        return -1;

    /* Decode while more data remains */
    while (state->data != state->end)
    {
        /* Decode the next four characters */
        if ((state->chars[0] = Dec((state->data[0]) & 0x7f)) == 0xFF ||
            (state->chars[1] = Dec((state->data[1]) & 0x7f)) == 0xFF ||
            (state->chars[2] = Dec((state->data[2]) & 0x7f)) == 0xFF ||
            (state->chars[3] = Dec((state->data[3]) & 0x7f)) == 0xFF)
        {
            return -1;
        }

        /* Advance data pointer beyond decoded characters */
        state->data += 4;

        /* If out of space, then return what is encoded so far */
        if (state->n + 3 > sizeOut)
        {
            size_t n = state->n;
            state->state = 1;
            state->n = 0;
            return n;
        }

state1:

        ((unsigned char*)dataOut)[state->n++] = 
            (state->chars[0] << 2) | (state->chars[1] >> 4);

        if (state->chars[2] != 64)
        {
            ((unsigned char*)dataOut)[state->n++] = 
                ((state->chars[1] & 0xF) << 4) | (state->chars[2] >> 2);
        }

        if (state->chars[3] != 64)
        {
            ((unsigned char*)dataOut)[state->n++] = 
                ((state->chars[2] & 0x3) << 6) | state->chars[3];
        }
    }

    /* Send any remaining bytes */
    if (state->n)
    {
        state->state = 2;
        return state->n;
    }

state2:

    return 0;
}
